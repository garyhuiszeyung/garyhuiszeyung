<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>幸運抽籤器 // Lucky Picker</title>
    <!-- 引入 Tailwind CSS 進行佈局 (使用 CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * Apple-style Design System 
         * 強調毛玻璃、柔和陰影與流暢動畫
         */
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            font-family: 'Inter', 'Noto Sans TC', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f0f2f5;
            /* 柔和的漸層背景 */
            background-image: 
                radial-gradient(at 0% 0%, hsla(253,16%,7%,1) 0, transparent 50%), 
                radial-gradient(at 50% 0%, hsla(225,39%,30%,1) 0, transparent 50%), 
                radial-gradient(at 100% 0%, hsla(339,49%,30%,1) 0, transparent 50%);
            background-size: cover;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* 防止 confetti 出現卷軸 */
        }

        /* 玻璃擬態卡片 */
        .glass-card {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1), 
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                inset 0 0 0 1px rgba(255,255,255,0.4);
        }

        /* 輸入框樣式 */
        .custom-textarea {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            resize: none;
        }
        .custom-textarea:focus {
            background: rgba(255, 255, 255, 0.9);
            outline: none;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15);
            border-color: #3b82f6;
        }

        /* 滾動名字顯示區 */
        .roller-window {
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: linear-gradient(180deg, #f3f4f6 0%, #ffffff 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }
        
        /* 獲勝者動畫 */
        .winner-animation {
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            color: #2563eb; /* Royal Blue */
            text-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1.1); opacity: 1; }
        }

        /* 按鈕互動 */
        .action-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: transform 0.1s, box-shadow 0.3s;
        }
        .action-btn:active {
            transform: scale(0.96);
        }
        .action-btn:hover {
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
        }
        .action-btn:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* 狀態切換 */
        .mode-input .show-on-roll { display: none; }
        .mode-rolling .hide-on-roll { display: none; }
    </style>
</head>
<body>

    <canvas id="confetti-canvas"></canvas>

    <!-- 主介面卡片 -->
    <div class="glass-card w-full max-w-md mx-4 rounded-3xl p-8 flex flex-col items-center relative z-10 transition-all duration-500" id="main-card">
        
        <!-- 標題 -->
        <div class="text-center mb-6">
            <h1 class="text-2xl font-bold text-gray-800 tracking-tight">隨機抽籤器</h1>
            <p class="text-sm text-gray-500 mt-1">公平、公正、公開</p>
        </div>

        <!-- 滾動顯示區 (平時隱藏，抽籤時顯示) -->
        <div id="roller-container" class="w-full mb-6 hidden">
            <div class="roller-window rounded-2xl border border-gray-200">
                <div id="roller-text" class="text-4xl font-black text-gray-800 tracking-wide">
                    READY
                </div>
            </div>
        </div>

        <!-- 輸入區 -->
        <div id="input-container" class="w-full mb-6">
            <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider mb-2 ml-1">
                參加者名單 (一行一個名字)
            </label>
            <textarea 
                id="names-input" 
                class="custom-textarea w-full h-48 rounded-2xl p-4 text-gray-700 text-lg leading-relaxed shadow-sm"
                placeholder="王小明&#10;李大華&#10;陳雅婷&#10;張偉..."
            ></textarea>
        </div>

        <!-- 控制區 -->
        <div class="w-full flex gap-3">
            <button 
                onclick="resetPicker()" 
                id="reset-btn"
                class="hidden w-1/3 py-4 rounded-2xl bg-gray-100 text-gray-600 font-bold hover:bg-gray-200 transition-colors"
            >
                重置
            </button>
            <button 
                onclick="startPicker()" 
                id="pick-btn"
                class="action-btn flex-1 py-4 rounded-2xl text-white font-bold text-lg shadow-lg tracking-wide"
            >
                開始抽籤！
            </button>
        </div>

    </div>

    <script>
        // --- 邏輯控制 ---

        const namesInput = document.getElementById('names-input');
        const rollerContainer = document.getElementById('roller-container');
        const inputContainer = document.getElementById('input-container');
        const rollerText = document.getElementById('roller-text');
        const pickBtn = document.getElementById('pick-btn');
        const resetBtn = document.getElementById('reset-btn');
        const mainCard = document.getElementById('main-card');

        let isRolling = false;

        function getNames() {
            return namesInput.value
                .split('\n')
                .map(n => n.trim())
                .filter(n => n.length > 0);
        }

        function startPicker() {
            const names = getNames();

            if (names.length < 2) {
                alert("請至少輸入兩個名字才能進行抽籤！");
                namesInput.focus();
                return;
            }

            if (isRolling) return;
            isRolling = true;

            // UI 狀態切換
            inputContainer.style.display = 'none';
            rollerContainer.style.display = 'block';
            rollerContainer.classList.remove('hidden'); // Tailwind hidden class
            pickBtn.disabled = true;
            pickBtn.innerText = "抽籤中...";
            
            // 重置文字樣式
            rollerText.classList.remove('winner-animation');
            rollerText.style.transform = 'scale(1)';
            rollerText.style.opacity = '1';
            rollerText.style.color = '#1f2937'; // gray-800

            // 啟動滾動邏輯
            let counter = 0;
            let speed = 50; // 初始速度 (毫秒)
            let rounds = 0; // 圈數
            const minRounds = 20; // 至少跳動次數
            
            // 決定贏家
            const winnerIndex = Math.floor(Math.random() * names.length);
            const winnerName = names[winnerIndex];

            // 遞迴函數模擬滾動與減速
            function roll() {
                // 隨機顯示 (除了最後一次顯示贏家)
                const randomName = names[Math.floor(Math.random() * names.length)];
                rollerText.innerText = randomName;

                counter++;

                if (counter > minRounds) {
                    // 開始減速
                    speed += 20;
                    
                    // 增加更明顯的頓挫感
                    if (counter > minRounds + 5) speed += 40;
                    if (counter > minRounds + 8) speed += 80;
                }

                if (speed < 400) {
                    setTimeout(roll, speed);
                } else {
                    // 停止，顯示贏家
                    finalize(winnerName);
                }
            }

            roll();
        }

        function finalize(winner) {
            rollerText.innerText = winner;
            rollerText.classList.add('winner-animation');
            
            // 按鈕狀態更新
            pickBtn.style.display = 'none';
            resetBtn.style.display = 'block';
            resetBtn.classList.remove('hidden');
            
            // 發射彩帶
            fireConfetti();
            
            // 讓卡片震動一下 (Haptic feedback visualization)
            mainCard.style.transform = 'scale(1.02)';
            setTimeout(() => mainCard.style.transform = 'scale(1)', 150);

            isRolling = false;
        }

        function resetPicker() {
            // 清除彩帶
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles = [];

            // UI 重置
            inputContainer.style.display = 'block';
            rollerContainer.style.display = 'none';
            
            pickBtn.style.display = 'block';
            pickBtn.disabled = false;
            pickBtn.innerText = "開始抽籤！";
            
            resetBtn.style.display = 'none';
        }


        // --- 自製 Confetti (彩帶) 物理引擎 ---
        // 為了符合「單一檔案」且不依賴不穩定的 CDN，這裡寫一個輕量級的 JS 實現

        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];

        // 設定 Canvas 尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff', '#ffae00'];

        class Particle {
            constructor() {
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight / 2;
                // 爆炸方向
                this.vx = (Math.random() - 0.5) * 25;
                this.vy = (Math.random() - 1) * 20 - 5; 
                this.gravity = 0.5;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.size = Math.random() * 10 + 5;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 10;
                this.opacity = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.rotation += this.rotationSpeed;
                this.opacity -= 0.005; // 慢慢消失
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        function fireConfetti() {
            // 產生 150 個粒子
            for (let i = 0; i < 150; i++) {
                particles.push(new Particle());
            }
            animateConfetti();
        }

        function animateConfetti() {
            if (particles.length === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw();

                // 移除超出畫面或透明的粒子
                if (particles[i].y > canvas.height || particles[i].opacity <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }

            requestAnimationFrame(animateConfetti);
        }

    </script>
</body>
</html>
